% Gather data for comparing computational effort for serial robot models

% Moritz Schappler, moritz.schappler@imes.uni-hannover.de, 2020-10
% (C) Institut für Mechatronische Systeme, Leibniz Universität Hannover

clc
clear

matlabfcnmode = 'dyncmp'; % modes: 'simple', 'dyncmp', 'full'
regen_serrob_table = true; % switch for force re-counting of of the serial robot database
serrobpath = fileparts(which('serroblib_path_init.m'));
if isempty(serrobpath)
  warning('Repository with serial robot models not in path. Abort.');
  return
end
hybrdynpath = fileparts(which('hybrdyn_path_init.m'));
if isempty(hybrdynpath)
  warning('Repository with code generation toolbox not in path. Abort.');
  return
end
addpath(fullfile(hybrdynpath, 'test'));
figure_dir = fileparts(which('statistics_serroblib.m'));
if isempty(figure_dir)
  error('This script has to be run at least by the "run" command');
end
%% Parse library of serial robot models
% go through all models and all code files
% assess computational cost of all matlab functions
% save everything in a mat file
codefilenames_sp = {{'inertia_sympybotics',3},{'coriolisvec_sympybotics', 4}...
                 {'gravload_sympybotics',5},{'invdyn_sympybotics',6},...
                 {'coriolismat_sympybotics',7},{'invdyn_reg_sympybotics',NaN}};
codefilenames_sy = {{'fkine_symoro',1},{'invdyn_symoro',6}};

if strcmp(matlabfcnmode, 'simple')
  codefilenames_hd = { ...
    {'fkine_fixb_rotmat_mdh_sym_varpar', 1}...
    {'joint_trafo_rotmat_mdh_sym_varpar', 1}, ...
    {'jacobig_rot_sym_varpar', 1}, ...
    {'jacobigD_rot_sym_varpar', 1}, ...
    {'jacobia_transl_sym_varpar', 1}, ...
    {'jacobiaD_transl_sym_varpar', 1}, ...
    {'energykin_fixb_regmin_slag_vp', 2}, ...
    {'energypot_fixb_regmin_slag_vp', 2}, ...
    {'inertiaJ_mdp_slag_vp', 3}, ...
    {'coriolisvecJ_fixb_mdp_slag_vp', 4}, ...
    {'gravloadJ_floatb_twist_mdp_slag_vp', 5}, ...
    {'invdynJ_fixb_mdp_slag_vp', 6}, ...
    {'coriolismatJ_fixb_regmin_slag_vp', 7}};
elseif strcmp(matlabfcnmode, 'dyncmp')
  codefilenames_hd = { ...
    {'invdynJ_fixb_mdp_slag_vp', 6}, ...
    {'invdynJ_fixb_snew_vp2', 6}};
else
  codefilenames_hd = { ...
    {'coriolismatJ_fixb_reg2_slag_vp', 7}, ...
    {'coriolismatJ_fixb_regmin_slag_vp', 7}, ...
    {'coriolismatJ_fixb_slag_vp1', 7}, ...
    {'coriolismatJ_fixb_slag_vp2', 7}, ...
    {'coriolisvecJ_fixb_mdp_slag_vp', 4}, ...
    {'coriolisvecJ_fixb_reg2_slag_vp', 4}, ...
    {'coriolisvecJ_fixb_regmin_slag_vp', 4}, ...
    {'coriolisvecJ_fixb_slag_vp1', 4}, ...
    {'coriolisvecJ_fixb_slag_vp2', 4}, ...
    {'energykin_fixb_reg2_slag_vp', 2}, ...
    {'energykin_fixb_regmin_slag_vp', 2}, ...
    {'energykin_fixb_slag_vp1', 2}, ...
    {'energykin_fixb_slag_vp2', 2}, ...
    {'energykin_floatb_twist_slag_vp1', 2}, ...
    {'energykin_floatb_twist_slag_vp2', 2}, ...
    {'energypot_fixb_reg2_slag_vp', 2}, ...
    {'energypot_fixb_regmin_slag_vp', 2}, ...
    {'energypot_fixb_slag_vp1', 2}, ...
    {'energypot_fixb_slag_vp2', 2}, ...
    {'energypot_floatb_twist_slag_vp1', 2}, ...
    {'energypot_floatb_twist_slag_vp2', 2}, ...
    {'fkine_fixb_rotmat_mdh_sym_varpar', 1}, ...
    {'gravloadJ_floatb_twist_mdp_slag_vp', 5}, ...
    {'gravloadJ_floatb_twist_slag_vp1', 5}, ...
    {'gravloadJ_floatb_twist_slag_vp2', 5}, ...
    {'gravloadJ_reg2_slag_vp', 5}, ...
    {'gravloadJ_regmin_slag_vp', 5}, ...
    {'inertiaDJ_reg2_slag_vp', NaN}, ...
    {'inertiaDJ_regmin_slag_vp', NaN}, ...
    {'inertiaDJ_slag_vp1', NaN}, ...
    {'inertiaDJ_slag_vp2', NaN}, ...
    {'inertiaJ_mdp_slag_vp', 3}, ...
    {'inertiaJ_reg2_slag_vp', 3}, ...
    {'inertiaJ_regmin_slag_vp', 3}, ...
    {'inertiaJ_slag_vp1', 3}, ...
    {'inertiaJ_slag_vp2', 3}, ...
    {'invdynB_fixb_reg2_snew_vp', NaN}, ...
    {'invdynB_fixb_snew_vp2', NaN}, ...
    {'invdynf_fixb_reg2_snew_vp', NaN}, ...
    {'invdynf_fixb_snew_vp2', NaN}, ...
    {'invdynJ_fixb_mdp_slag_vp', 6}, ...
    {'invdynJ_fixb_reg2_slag_vp', 6}, ...
    {'invdynJ_fixb_reg2_snew_vp', 6}, ...
    {'invdynJ_fixb_regmin_slag_vp', 6}, ...
    {'invdynJ_fixb_slag_vp1', 6}, ...
    {'invdynJ_fixb_slag_vp2', 6}, ...
    {'invdynJ_fixb_snew_vp2', 6}, ...
    {'invdynm_fixb_reg2_snew_vp', NaN}, ...
    {'invdynm_fixb_snew_vp2', NaN}, ...
    {'jacobiaD_rot_sym_varpar', 1}, ...
    {'jacobiaD_transl_sym_varpar', 1}, ...
    {'jacobia_rot_sym_varpar', 1}, ...
    {'jacobia_transl_sym_varpar', 1}, ...
    {'jacobigD_rot_sym_varpar', 1}, ...
    {'jacobig_rot_sym_varpar', 1}, ...
    {'jacobiRD_rot_sym_varpar', 1}, ...
    {'jacobiR_rot_sym_varpar', 1}, ...
    {'joint_trafo_rotmat_mdh_sym_varpar', 1}};
end
serrob_stat_file = fullfile(figure_dir, sprintf('statistics_serroblib_%s.mat',matlabfcnmode));
if regen_serrob_table || ~exist(serrob_stat_file, 'file')
  head_row = {'Name', 'NumDoF', 'CodeFile', 'DurationCPUTime', 'ComputationalCostSum', ...
    'OptCodeLineCount', 'OptCodeSize', 'FileSize'};
  CompEffortTable_sp = cell2table(cell(0,length(head_row)), 'VariableNames', head_row);
  CompEffortTable_sy = cell2table(cell(0,length(head_row)), 'VariableNames', head_row);
  CompEffortTable_hd = cell2table(cell(0,length(head_row)), 'VariableNames', head_row);
  filelist_invalid = {};
  for N = 1:7
    dir_Ndof = fullfile(serrobpath, sprintf('mdl_%ddof', N));
    mdllistfile_Ndof = fullfile(dir_Ndof, sprintf('S%d_list.mat',N));
    l = load(mdllistfile_Ndof, 'Names_Ndof', 'AdditionalInfo');
    
    I = find(l.AdditionalInfo(:,2) == 0);
    
    % Sort Table according to number of joints and revolute joints
    NrotJ_all = l.AdditionalInfo(I,5);
    [~, II_sortrotJ] = sort(NrotJ_all);
    I_sortrotJ = I(II_sortrotJ);
    if ~all(intersect(I_sortrotJ, I) == I)
      error('Error sorting the robots regarding number of revolute joints');
    end
    fprintf('Go through serial robot models with %d DoF (%d robots).\n', N, length(I));
    for ii = I_sortrotJ(:)'
      Name = l.Names_Ndof{ii};
      % Debug: Only check one robot for testing
      % if ~strcmp(Name, 'S4PRPR1'), continue; end
      fprintf('%s\n', Name);
      %% Read Information for Function files of Proposed Dynamics Toolbox
      codedir = fullfile(dir_Ndof, Name, 'hd');
      for jj = 1:length(codefilenames_hd)
        codefile_jj = fullfile(codedir, [Name, '_', codefilenames_hd{jj}{1}, '.m']);
        if ~exist(codefile_jj, 'file')
          continue
        end
        infostruct = get_codegen_info_from_matlabfcn(codefile_jj);
        if isnan(infostruct.OptimizationMode)
          warning('No valid codegen information in file %s', codefile_jj);
          filelist_invalid = [filelist_invalid; {codefile_jj}]; %#ok<AGROW>
        end
        cc = infostruct.ComputationalCostDebug;
        cc_maple = infostruct.ComputationalCost;
        if any(abs(cc_maple.ass - cc.ass) > 1)
          error('Number of assignments strongly diverging between Matlab/Maple');
        end
        if any(abs(cc_maple.fcn - cc.fcn) > 1)
          error('Number of function calls diverging between Matlab/Maple');
        end
        % Use the count of operations in Matlab instead of the counting
        % from Maple code generation to have the same counting method for
        % all toolboxes
        ComputationalCostSum = sum(cc.add+cc.mult+cc.div+cc.fcn+cc.ass);
        Row_jj = {Name, N, jj, sum(infostruct.DurationCPUTime), ComputationalCostSum, ...
          sum(infostruct.OptCodeLineCount), sum(infostruct.OptCodeSize), infostruct.FileSize};
        CompEffortTable_hd = [CompEffortTable_hd; Row_jj]; %#ok<AGROW>
      end
      %% Read Information for Function files of Other Toolboxes
      for tb = 1:2
        if tb == 1, codename = codefilenames_sp; cdir='sp';  % SymPyBotics
        else,       codename = codefilenames_sy; cdir='sy'; end % Symoro
        code_dir = fullfile(serrobpath, sprintf('mdl_%ddof', N), Name, cdir);
        for  jj = 1: length(codename)
          codefile_jj = fullfile(code_dir, [Name, '_', codename{jj}{1},'.m']);
          if ~exist(codefile_jj, 'file')
            continue;
          end
          infostruct = count_operations_in_matlabfcn(codefile_jj);
          cc = infostruct.ComputationalCost;
          ComputationalCostSum = sum(cc.add+cc.mult+cc.div+cc.fcn+cc.ass);
          Row_jj = {Name, N, jj, NaN, ComputationalCostSum, ...
            NaN, NaN, infostruct.FileSize};
          if tb == 1
            CompEffortTable_sp = [CompEffortTable_sp; Row_jj]; %#ok<AGROW>
          else
            CompEffortTable_sy = [CompEffortTable_sy; Row_jj]; %#ok<AGROW>
          end
        end
      end
    end
  end
  save(serrob_stat_file, 'CompEffortTable_hd', 'CompEffortTable_sp', ...
    'CompEffortTable_sy', 'filelist_invalid');
  writecell(filelist_invalid, fullfile(figure_dir, 'statistics_serroblib_files_invalid.txt'));
else
  load(serrob_stat_file, 'CompEffortTable_hd', 'CompEffortTable_sp', ...
    'CompEffortTable_sy', 'filelist_invalid');
end

%% Group code files into categories
% By doing this here, the categories can be changed afterwards without
% having to parse the whole database again.
codefilecategories = NaN(length(codefilenames_hd),1);
for i = 1:length(codefilenames_hd)
  codefilecategories(i) = codefilenames_hd{i}{2};
end
% Append categories to table (if not already existing from multiple runs)
if ~any(strcmp('FileCategory', CompEffortTable_hd.Properties.VariableNames))
  CompEffortTable_hd = addvars(CompEffortTable_hd, NaN(size(CompEffortTable_hd,1),1), 'After', 3);
  CompEffortTable_hd.Properties.VariableNames(4) = {'FileCategory'};
end
for i = 1:length(codefilenames_hd)
  I = CompEffortTable_hd.CodeFile == i;
  CompEffortTable_hd.FileCategory(I) = codefilecategories(i);
end

%% Save file again (with added information)
serrob_stat_file = fullfile(figure_dir, sprintf('statistics_serroblib_%s.mat',matlabfcnmode));
save(serrob_stat_file, 'CompEffortTable_hd', 'CompEffortTable_sp', ...
  'CompEffortTable_sy', 'filelist_invalid', 'codefilecategories');
fprintf('Parsed database and saved everything to %s\n', serrob_stat_file);
